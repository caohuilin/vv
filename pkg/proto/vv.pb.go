// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pkg/proto/vv.proto

/*
Package vv is a generated protocol buffer package.

It is generated from these files:
	pkg/proto/vv.proto

It has these top-level messages:
	PingRequest
	PingReply
	OpenFileRequest
	OpenFileReply
	ProtoHeader
	OpenListenRequest
	OpenListenReply
*/
package vv

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ProtoHeader_ServerKind int32

const (
	ProtoHeader_UNKNOWN_SERVER_KIND ProtoHeader_ServerKind = 0
	ProtoHeader_SERVER              ProtoHeader_ServerKind = 1
	ProtoHeader_CLIENT              ProtoHeader_ServerKind = 2
)

var ProtoHeader_ServerKind_name = map[int32]string{
	0: "UNKNOWN_SERVER_KIND",
	1: "SERVER",
	2: "CLIENT",
}
var ProtoHeader_ServerKind_value = map[string]int32{
	"UNKNOWN_SERVER_KIND": 0,
	"SERVER":              1,
	"CLIENT":              2,
}

func (x ProtoHeader_ServerKind) String() string {
	return proto.EnumName(ProtoHeader_ServerKind_name, int32(x))
}
func (ProtoHeader_ServerKind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type ProtoHeader_ConnKind int32

const (
	ProtoHeader_UNKNOWN_CONN_KIND ProtoHeader_ConnKind = 0
	ProtoHeader_LISTEN            ProtoHeader_ConnKind = 1
	ProtoHeader_DIAL              ProtoHeader_ConnKind = 2
)

var ProtoHeader_ConnKind_name = map[int32]string{
	0: "UNKNOWN_CONN_KIND",
	1: "LISTEN",
	2: "DIAL",
}
var ProtoHeader_ConnKind_value = map[string]int32{
	"UNKNOWN_CONN_KIND": 0,
	"LISTEN":            1,
	"DIAL":              2,
}

func (x ProtoHeader_ConnKind) String() string {
	return proto.EnumName(ProtoHeader_ConnKind_name, int32(x))
}
func (ProtoHeader_ConnKind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

type PingRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *PingRequest) Reset()                    { *m = PingRequest{} }
func (m *PingRequest) String() string            { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()               {}
func (*PingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PingRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PingReply struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *PingReply) Reset()                    { *m = PingReply{} }
func (m *PingReply) String() string            { return proto.CompactTextString(m) }
func (*PingReply) ProtoMessage()               {}
func (*PingReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PingReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type OpenFileRequest struct {
	FileName string `protobuf:"bytes,1,opt,name=fileName" json:"fileName,omitempty"`
	Content  []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	Dir      string `protobuf:"bytes,3,opt,name=dir" json:"dir,omitempty"`
	IsEnd    bool   `protobuf:"varint,4,opt,name=isEnd" json:"isEnd,omitempty"`
}

func (m *OpenFileRequest) Reset()                    { *m = OpenFileRequest{} }
func (m *OpenFileRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenFileRequest) ProtoMessage()               {}
func (*OpenFileRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *OpenFileRequest) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *OpenFileRequest) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *OpenFileRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *OpenFileRequest) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

type OpenFileReply struct {
	Content  []byte `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	IsBsdiff bool   `protobuf:"varint,2,opt,name=isBsdiff" json:"isBsdiff,omitempty"`
	Crc      []byte `protobuf:"bytes,3,opt,name=crc,proto3" json:"crc,omitempty"`
}

func (m *OpenFileReply) Reset()                    { *m = OpenFileReply{} }
func (m *OpenFileReply) String() string            { return proto.CompactTextString(m) }
func (*OpenFileReply) ProtoMessage()               {}
func (*OpenFileReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *OpenFileReply) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *OpenFileReply) GetIsBsdiff() bool {
	if m != nil {
		return m.IsBsdiff
	}
	return false
}

func (m *OpenFileReply) GetCrc() []byte {
	if m != nil {
		return m.Crc
	}
	return nil
}

// 握手的header
type ProtoHeader struct {
	Version    string                 `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	User       string                 `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Password   string                 `protobuf:"bytes,5,opt,name=password" json:"password,omitempty"`
	ServerKind ProtoHeader_ServerKind `protobuf:"varint,3,opt,name=serverKind,enum=vv.ProtoHeader_ServerKind" json:"serverKind,omitempty"`
	ConnKind   ProtoHeader_ConnKind   `protobuf:"varint,4,opt,name=connKind,enum=vv.ProtoHeader_ConnKind" json:"connKind,omitempty"`
}

func (m *ProtoHeader) Reset()                    { *m = ProtoHeader{} }
func (m *ProtoHeader) String() string            { return proto.CompactTextString(m) }
func (*ProtoHeader) ProtoMessage()               {}
func (*ProtoHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ProtoHeader) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ProtoHeader) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ProtoHeader) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *ProtoHeader) GetServerKind() ProtoHeader_ServerKind {
	if m != nil {
		return m.ServerKind
	}
	return ProtoHeader_UNKNOWN_SERVER_KIND
}

func (m *ProtoHeader) GetConnKind() ProtoHeader_ConnKind {
	if m != nil {
		return m.ConnKind
	}
	return ProtoHeader_UNKNOWN_CONN_KIND
}

type OpenListenRequest struct {
	User string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
}

func (m *OpenListenRequest) Reset()                    { *m = OpenListenRequest{} }
func (m *OpenListenRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenListenRequest) ProtoMessage()               {}
func (*OpenListenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *OpenListenRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type OpenListenReply struct {
}

func (m *OpenListenReply) Reset()                    { *m = OpenListenReply{} }
func (m *OpenListenReply) String() string            { return proto.CompactTextString(m) }
func (*OpenListenReply) ProtoMessage()               {}
func (*OpenListenReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func init() {
	proto.RegisterType((*PingRequest)(nil), "vv.PingRequest")
	proto.RegisterType((*PingReply)(nil), "vv.PingReply")
	proto.RegisterType((*OpenFileRequest)(nil), "vv.OpenFileRequest")
	proto.RegisterType((*OpenFileReply)(nil), "vv.OpenFileReply")
	proto.RegisterType((*ProtoHeader)(nil), "vv.ProtoHeader")
	proto.RegisterType((*OpenListenRequest)(nil), "vv.OpenListenRequest")
	proto.RegisterType((*OpenListenReply)(nil), "vv.OpenListenReply")
	proto.RegisterEnum("vv.ProtoHeader_ServerKind", ProtoHeader_ServerKind_name, ProtoHeader_ServerKind_value)
	proto.RegisterEnum("vv.ProtoHeader_ConnKind", ProtoHeader_ConnKind_name, ProtoHeader_ConnKind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for VvServer service

type VvServerClient interface {
	// 握手消息
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error)
	// 打开文件，返回文件修改流
	// TODO 打开大文件
	OpenFile(ctx context.Context, in *OpenFileRequest, opts ...grpc.CallOption) (VvServer_OpenFileClient, error)
	OpenFileStream(ctx context.Context, opts ...grpc.CallOption) (VvServer_OpenFileStreamClient, error)
}

type vvServerClient struct {
	cc *grpc.ClientConn
}

func NewVvServerClient(cc *grpc.ClientConn) VvServerClient {
	return &vvServerClient{cc}
}

func (c *vvServerClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error) {
	out := new(PingReply)
	err := grpc.Invoke(ctx, "/vv.VvServer/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vvServerClient) OpenFile(ctx context.Context, in *OpenFileRequest, opts ...grpc.CallOption) (VvServer_OpenFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VvServer_serviceDesc.Streams[0], c.cc, "/vv.VvServer/OpenFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &vvServerOpenFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VvServer_OpenFileClient interface {
	Recv() (*OpenFileReply, error)
	grpc.ClientStream
}

type vvServerOpenFileClient struct {
	grpc.ClientStream
}

func (x *vvServerOpenFileClient) Recv() (*OpenFileReply, error) {
	m := new(OpenFileReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vvServerClient) OpenFileStream(ctx context.Context, opts ...grpc.CallOption) (VvServer_OpenFileStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VvServer_serviceDesc.Streams[1], c.cc, "/vv.VvServer/OpenFileStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vvServerOpenFileStreamClient{stream}
	return x, nil
}

type VvServer_OpenFileStreamClient interface {
	Send(*OpenFileRequest) error
	Recv() (*OpenFileReply, error)
	grpc.ClientStream
}

type vvServerOpenFileStreamClient struct {
	grpc.ClientStream
}

func (x *vvServerOpenFileStreamClient) Send(m *OpenFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vvServerOpenFileStreamClient) Recv() (*OpenFileReply, error) {
	m := new(OpenFileReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for VvServer service

type VvServerServer interface {
	// 握手消息
	Ping(context.Context, *PingRequest) (*PingReply, error)
	// 打开文件，返回文件修改流
	// TODO 打开大文件
	OpenFile(*OpenFileRequest, VvServer_OpenFileServer) error
	OpenFileStream(VvServer_OpenFileStreamServer) error
}

func RegisterVvServerServer(s *grpc.Server, srv VvServerServer) {
	s.RegisterService(&_VvServer_serviceDesc, srv)
}

func _VvServer_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VvServerServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vv.VvServer/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VvServerServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VvServer_OpenFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OpenFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VvServerServer).OpenFile(m, &vvServerOpenFileServer{stream})
}

type VvServer_OpenFileServer interface {
	Send(*OpenFileReply) error
	grpc.ServerStream
}

type vvServerOpenFileServer struct {
	grpc.ServerStream
}

func (x *vvServerOpenFileServer) Send(m *OpenFileReply) error {
	return x.ServerStream.SendMsg(m)
}

func _VvServer_OpenFileStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VvServerServer).OpenFileStream(&vvServerOpenFileStreamServer{stream})
}

type VvServer_OpenFileStreamServer interface {
	Send(*OpenFileReply) error
	Recv() (*OpenFileRequest, error)
	grpc.ServerStream
}

type vvServerOpenFileStreamServer struct {
	grpc.ServerStream
}

func (x *vvServerOpenFileStreamServer) Send(m *OpenFileReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vvServerOpenFileStreamServer) Recv() (*OpenFileRequest, error) {
	m := new(OpenFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _VvServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vv.VvServer",
	HandlerType: (*VvServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _VvServer_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenFile",
			Handler:       _VvServer_OpenFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OpenFileStream",
			Handler:       _VvServer_OpenFileStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/proto/vv.proto",
}

// Client API for VvRegistry service

type VvRegistryClient interface {
	OpenListen(ctx context.Context, in *OpenListenRequest, opts ...grpc.CallOption) (VvRegistry_OpenListenClient, error)
}

type vvRegistryClient struct {
	cc *grpc.ClientConn
}

func NewVvRegistryClient(cc *grpc.ClientConn) VvRegistryClient {
	return &vvRegistryClient{cc}
}

func (c *vvRegistryClient) OpenListen(ctx context.Context, in *OpenListenRequest, opts ...grpc.CallOption) (VvRegistry_OpenListenClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VvRegistry_serviceDesc.Streams[0], c.cc, "/vv.VvRegistry/OpenListen", opts...)
	if err != nil {
		return nil, err
	}
	x := &vvRegistryOpenListenClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VvRegistry_OpenListenClient interface {
	Recv() (*OpenListenReply, error)
	grpc.ClientStream
}

type vvRegistryOpenListenClient struct {
	grpc.ClientStream
}

func (x *vvRegistryOpenListenClient) Recv() (*OpenListenReply, error) {
	m := new(OpenListenReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for VvRegistry service

type VvRegistryServer interface {
	OpenListen(*OpenListenRequest, VvRegistry_OpenListenServer) error
}

func RegisterVvRegistryServer(s *grpc.Server, srv VvRegistryServer) {
	s.RegisterService(&_VvRegistry_serviceDesc, srv)
}

func _VvRegistry_OpenListen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OpenListenRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VvRegistryServer).OpenListen(m, &vvRegistryOpenListenServer{stream})
}

type VvRegistry_OpenListenServer interface {
	Send(*OpenListenReply) error
	grpc.ServerStream
}

type vvRegistryOpenListenServer struct {
	grpc.ServerStream
}

func (x *vvRegistryOpenListenServer) Send(m *OpenListenReply) error {
	return x.ServerStream.SendMsg(m)
}

var _VvRegistry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vv.VvRegistry",
	HandlerType: (*VvRegistryServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenListen",
			Handler:       _VvRegistry_OpenListen_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/proto/vv.proto",
}

func init() { proto.RegisterFile("pkg/proto/vv.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xcd, 0x6e, 0xda, 0x4e,
	0x10, 0xcf, 0x12, 0x92, 0x38, 0x93, 0x2f, 0xb3, 0xfc, 0xa3, 0xbf, 0xe5, 0x4b, 0xa9, 0xa5, 0xaa,
	0x9c, 0x9c, 0x88, 0x56, 0xad, 0x54, 0xb5, 0x95, 0x0a, 0xa1, 0x2a, 0x05, 0x19, 0xb4, 0xa4, 0xe4,
	0x18, 0x11, 0x7b, 0x21, 0xab, 0xc0, 0xda, 0xdd, 0x35, 0x1b, 0xf1, 0x4e, 0x7d, 0x89, 0xbe, 0x59,
	0xb5, 0x6b, 0x8c, 0x01, 0xf5, 0xd0, 0xdb, 0xcc, 0xf8, 0xf7, 0x31, 0x33, 0x3b, 0x06, 0x9c, 0x3c,
	0x4d, 0xaf, 0x12, 0x11, 0xa7, 0xf1, 0x95, 0x52, 0xbe, 0x09, 0x70, 0x49, 0x29, 0xef, 0x25, 0x9c,
	0x0c, 0x18, 0x9f, 0x12, 0xfa, 0x73, 0x41, 0x65, 0x8a, 0x31, 0x94, 0xf9, 0x78, 0x4e, 0x1d, 0x54,
	0x43, 0xf5, 0x63, 0x62, 0x62, 0xef, 0x05, 0x1c, 0x67, 0x90, 0x64, 0xb6, 0xfc, 0x2b, 0x20, 0x86,
	0x8b, 0x7e, 0x42, 0xf9, 0x57, 0x36, 0xa3, 0xb9, 0x8e, 0x0b, 0xd6, 0x84, 0xcd, 0x68, 0x50, 0x40,
	0xd7, 0x39, 0x76, 0xe0, 0x28, 0x8c, 0x79, 0x4a, 0x79, 0xea, 0x94, 0x6a, 0xa8, 0x7e, 0x4a, 0xf2,
	0x14, 0xdb, 0xb0, 0x1f, 0x31, 0xe1, 0xec, 0x1b, 0x82, 0x0e, 0xf1, 0x7f, 0x70, 0xc0, 0x64, 0x9b,
	0x47, 0x4e, 0xb9, 0x86, 0xea, 0x16, 0xc9, 0x12, 0xef, 0x0e, 0xce, 0x0a, 0x43, 0xdd, 0xd5, 0x86,
	0x24, 0xda, 0x96, 0x74, 0xc1, 0x62, 0xb2, 0x29, 0x23, 0x36, 0x99, 0x18, 0x37, 0x8b, 0xac, 0x73,
	0x6d, 0x17, 0x8a, 0xd0, 0xd8, 0x9d, 0x12, 0x1d, 0x7a, 0xbf, 0x4b, 0x70, 0x32, 0xd0, 0xbb, 0xf9,
	0x46, 0xc7, 0x11, 0x15, 0x5a, 0x57, 0x51, 0x21, 0x59, 0xcc, 0x57, 0x53, 0xe4, 0xa9, 0xde, 0xc3,
	0x42, 0x52, 0x61, 0x34, 0x8f, 0x89, 0x89, 0xb5, 0x57, 0x32, 0x96, 0xf2, 0x39, 0x16, 0x91, 0x73,
	0x90, 0x0d, 0x9d, 0xe7, 0xf8, 0x03, 0x80, 0xa4, 0x42, 0x51, 0xd1, 0x65, 0x3c, 0x32, 0x96, 0xe7,
	0x0d, 0xd7, 0x57, 0xca, 0xdf, 0xb0, 0xf3, 0x87, 0x6b, 0x04, 0xd9, 0x40, 0xe3, 0xb7, 0x60, 0x85,
	0x31, 0xe7, 0x86, 0x59, 0x36, 0x4c, 0x67, 0x97, 0xd9, 0x5a, 0x7d, 0x27, 0x6b, 0xa4, 0xf7, 0x09,
	0xa0, 0xd0, 0xc3, 0xff, 0x43, 0xf5, 0x47, 0xd0, 0x0d, 0xfa, 0x77, 0xc1, 0xfd, 0xb0, 0x4d, 0x46,
	0x6d, 0x72, 0xdf, 0xed, 0x04, 0x37, 0xf6, 0x1e, 0x06, 0x38, 0xcc, 0x0a, 0x36, 0xd2, 0x71, 0xab,
	0xd7, 0x69, 0x07, 0xb7, 0x76, 0xc9, 0x7b, 0x0f, 0x56, 0x2e, 0x8a, 0x2f, 0xa1, 0x92, 0x93, 0x5b,
	0xfd, 0x20, 0xd8, 0xa0, 0xf6, 0x3a, 0xc3, 0xdb, 0x76, 0x60, 0x23, 0x6c, 0x41, 0xf9, 0xa6, 0xf3,
	0xa5, 0x67, 0x97, 0xbc, 0xd7, 0x50, 0xd1, 0x8f, 0xd3, 0x63, 0x32, 0xa5, 0x7c, 0xe3, 0xae, 0xcc,
	0xba, 0x50, 0xb1, 0x2e, 0xaf, 0x92, 0x9d, 0x4d, 0x0e, 0x4c, 0x66, 0xcb, 0xc6, 0x2f, 0x04, 0xd6,
	0x48, 0x65, 0x6d, 0xe3, 0x3a, 0x94, 0xf5, 0xdd, 0xe1, 0x0b, 0x33, 0x6c, 0x71, 0xa4, 0xee, 0x59,
	0x51, 0x48, 0x66, 0x4b, 0x6f, 0x0f, 0xbf, 0x03, 0x2b, 0xbf, 0x07, 0x5c, 0xd5, 0x1f, 0x77, 0xce,
	0xd1, 0xad, 0x6c, 0x17, 0x0d, 0xeb, 0x1a, 0xe1, 0xcf, 0x70, 0x9e, 0x17, 0x87, 0xa9, 0xa0, 0xe3,
	0xf9, 0xbf, 0xb3, 0xeb, 0xe8, 0x1a, 0x35, 0xbe, 0x03, 0x8c, 0x14, 0xa1, 0x53, 0x26, 0x53, 0xb1,
	0xc4, 0x1f, 0x01, 0x8a, 0x79, 0xf0, 0x65, 0x4e, 0xda, 0x5a, 0x84, 0x5b, 0xdd, 0x2d, 0xaf, 0x7a,
	0x69, 0xbe, 0x02, 0x27, 0x8c, 0xe7, 0xfe, 0x94, 0xa5, 0x8f, 0x8b, 0x07, 0xff, 0x79, 0xcc, 0xa7,
	0x4f, 0x34, 0x7c, 0x5c, 0x70, 0x5f, 0xa9, 0xe6, 0xd1, 0x48, 0x99, 0xc7, 0x1e, 0xa0, 0x87, 0x43,
	0xf3, 0xeb, 0xbe, 0xf9, 0x13, 0x00, 0x00, 0xff, 0xff, 0x79, 0xba, 0x3d, 0xde, 0xd0, 0x03, 0x00,
	0x00,
}
